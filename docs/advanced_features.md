---
layout: default
title: Advanced features
mathjax: true
---

# Advanced features

## Simulation restarts

(See `examples/notebooks/restart_simulation.ipynb` for an example of how to restart a QDYN simulation)

Sometimes it can be useful to break a simulation into multiple phases, for instance if cluster CPU time is capped, or if a parametric study is performed starting from a (steady-state) reference simulation. To facilitate this, QDYN will generate a special snapshot file (`output_ox_last`) with full spatial resolution at the end of the simulation run. This snapshot contains the exact state of the fault, which serves as the starting point for the next simulation.

To commence a simulation restart, first run the initial simulation until the end (so that `output_ox_last` is created). Optionally, modify the model/simulation/mesh parameters through the wrapper, followed by `qdyn.run(restart=True)`. By specifying `restart=True`, the contents of `output_ox_last` will be read and a new `qdyn.in` input file is created (including the optional changes made to the simulation parameters). Internally, the wrapper will call the compiled `qdyn` executable with the `restart` flag to communicate our intention to restart the simulation. The simulation will then continue from this new initial state, and the simulation output is appended to the output files generated by the previous simulation.

One strategy to spawn numerous simulations from a single reference simulation on a cluster (e.g. for a parametric study) is as follows:

1. Run a reference simulation.
2. Create separate directories for each parameter value.
3. Copy the reference simulation output into each directory.
4. For each parameter, use the wrapper to modify the simulation settings and call `qdyn.run(restart=True, run=False)` to create a new `qdyn.in` file with the desired parameters, but without immediately launching the simulation. Either copy this `qdyn.in` file to each directory, or run the wrapper script directly in a given directory.
5. Call `qdyn restart` from each directory using the protocol used by the cluster (e.g. torque)

Steps 2-5 can be performed over a loop by a simple batch script.

## Complex geometries

(See `examples/notebooks/3D_mesh_builder.ipynb` and `examples/notebooks/intersecting_faults` for examples of how to use the mesh builder for (multiple) non-planar fault geometries)

For 2D faults embedded in 3D media, it is possible to construct non-planar and discontinuous fault meshes. As currently implemented in the QDYN code, a Fourier Transformation is applied in the along-strike direction of the mesh. This requires that the mesh be continuous, evenly spaced, and co-linear along this dimension, and that the number of mesh elements be an integer power of 2. These restrictions do not apply in the along-dip direction, allowing the user some freedom in creating non-planar mesh geometries. For instance, one could create a curved fault to simulate a subduction thrust geometry, or create multiple disjoint fault segments. 

By default, a uniform planar mesh is generated upon calling `qdyn.generate_mesh()`. The mesh node coordinates, size, and orientation (strike/dip) can then be adjusted by the user, similar to setting specific frictional properties or initial conditions over the fault. The wrapper contains a helper tool (`qdyn.compute_mesh_coords()`) to re-construct a mesh with user-specific variable dip angle and spacing values. After that, the user can decide to split the mesh along the dip direction into several independent faults and adjust their positions according to the desired fault geometry (see `examples/notebooks/3D_mesh_builder.ipynb`). Even though this approach permits a lot of freedom for designing custom fault geometries, the restrictions pointed out above still apply: the newly generated fault mesh needs to be uniform and co-linear along the along-strike direction. Currently there are no internal checks to automatically verify that these conditions are satisfied.

It is possible to approximate a scenario with along-strike variations in the fault geometry if free-surface effects are negligible. In a homogeneous elastic medium, there is no concrete notion of up-down or left-right, and so the definition of strike and dip are arbitrary. In the absence of a free surface that breaks this symmetry, the user can simply rotate the fault by 90Â°, effectively swapping what is "along-strike" and "along-dip". The `intersecting_faults.ipynb` example notebook demonstrates how this trick can be leveraged to simulate two intersecting strike-slip faults with constant dip (vertical). To ensure the validity of the results, the faults are put at an arbitrarily large depth away from the free surface.
